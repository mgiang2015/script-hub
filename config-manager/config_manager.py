from pathlib import Path
from typing import Dict, Any
import yaml
import json

class ConfigManager:
    def __init__(self, config_dir: str = "configs"):
        self.config_dir = Path(config_dir)
    

    def deep_merge(self, base_config: Dict[Any, Any], env_config: Dict[Any, Any]) -> Dict[Any, Any]:
        result = base_config.copy()

        for key, value in env_config.items():
            # Handles nested configuration cases
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self.deep_merge(result[key], value)
            # non-nested cases / no repeat cases
            else:
                result[key] = value
        return result
    
    def flatten_config(self, config: Dict[Any, Any], parent_key: str = '', seperator: str = '_') -> list:
        items = [] # Starts with a list for using `extend` method
        for k, v in config.items():
            new_key = f"{parent_key}{seperator}{k}" if parent_key else f"{k}"
            if isinstance(v, dict):
                items.extend(self.flatten_config(config=v, parent_key=parent_key, seperator=seperator))
            else:
                items.append((new_key.upper(), v))
        return items

    def load_file(self, file_name: str) -> Any:
        path = self.config_dir / file_name

        if not path.exists():
            raise FileNotFoundError(f"Config not found: {file_name}.yaml")
        
        return yaml.safe_load(open(path, 'r'))


    def load_config(self, environment: str) -> Dict[Any, Any]: # Loads configuration from base.yml and {environment}.yml    
        base_config = self.load_file("base.yaml")
        env_config = self.load_file(f"{environment}.yaml")

        return self.deep_merge(base_config=base_config, env_config=env_config)

    def generate_env_file(self, config: Dict[Any, Any], output_path: str):
        print(f"Generating .env file for {output_path}")
        flattened = dict(self.flatten_config(config=config))
        with open(output_path, 'w') as f:
            f.write("# AUTO-GENERATED CONFIG FILE. DO NOT EDIT THIS FILE MANUALLY\n")
            for k, v in flattened.items():
                if isinstance(v, list):
                    v = json.dumps(v)
                else:
                    v = str(v).lower()
                f.write(f"{k}={v}\n")


    def generate_json_config(self, config: Dict[Any, Any], output_path: str):
        print(f"Generating config.json file for {output_path}")
        with open(output_path, 'w') as f:
            json.dump(config, f, indent=2, default=str)


def main():
    manager = ConfigManager()
    environments = ['dev', 'staging', 'prod']

    for env in environments:
        print(f"----- Generating config files for {env.upper()} -----")
        
        try:
            config = manager.load_config(env)

            # Ensure output directory exists
            output_dir = Path(f"output/{env}")
            output_dir.mkdir(parents=True, exist_ok=True)

            # Generate
            manager.generate_env_file(config, f"output/{env}/.env")
            manager.generate_json_config(config, f"output/{env}/config.json")

            # Print confirmation
            print(f"✓ Generated .env file")
            print(f"✓ Generated config.json")
        except Exception as e:
            print(f"Error processing {env}: {e}")


if __name__ == "__main__":
    main()